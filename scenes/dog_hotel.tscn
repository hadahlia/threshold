[gd_scene load_steps=46 format=3 uid="uid://dnmjca1g5ibft"]

[ext_resource type="Texture2D" uid="uid://c3wevnt7ikktj" path="res://asset/blue_brick.png" id="3_o4pdu"]
[ext_resource type="Texture2D" uid="uid://bqie4pmd5w8gn" path="res://asset/red_heaven.png" id="4_ovrrc"]
[ext_resource type="PackedScene" uid="uid://utivt0bw6tds" path="res://scenes/yua_player.tscn" id="5_8l85i"]
[ext_resource type="PackedScene" uid="uid://usb2cwpjkpt" path="res://asset/Floor-col.gltf" id="6_1ch45"]
[ext_resource type="PackedScene" uid="uid://c2mrvqrh6li3k" path="res://asset/Wall-col.gltf" id="7_7kujf"]
[ext_resource type="Script" path="res://scenes/death_puppy.gd" id="8_40vij"]

[sub_resource type="GDScript" id="GDScript_x1wqk"]
script/source = "@tool
class_name QodotMap
extends QodotNode3D

## Builds Godot scenes from .map files
##
## A QodotMap node lets you define the source file for a map, as well as specify
## the definitions for entities, textures, and materials that appear in the map.
## To use this node, select an instance of the node in the Godot editor and
## select \"Quick Build\", \"Full Build\", or \"Unwrap UV2\" from the toolbar.
## Alternatively, call [method manual_build] from code.
##
## @tutorial: https://qodotplugin.github.io/docs/beginner's-guide-to-qodot/

## Force reinitialization of Qodot on map build
const DEBUG := false
## How long to wait between child/owner batches
const YIELD_DURATION := 0.0

## Emitted when the build process successfully completes
signal build_complete()
## Emitted when the build process finishes a step. [code]progress[/code] is from 0.0-1.0
signal build_progress(step, progress)
## Emitted when the build process fails
signal build_failed()

## Emitted when UV2 unwrapping is completed
signal unwrap_uv2_complete()

@export_category(\"Map\")
## Trenchbroom Map file to build a scene from
@export_global_file(\"*.map\") var map_file := \"\"
## Ratio between Trenchbroom units in the .map file and Godot units.
## An inverse scale factor of 16 would cause 16 Trenchbroom units to correspond to 1 Godot unit. See [url=https://qodotplugin.github.io/docs/geometry.html#scale]Scale[/url] in the Qodot documentation.
@export var inverse_scale_factor := 16.0
@export_category(\"Entities\")
## [QodotFGDFile] for the map.
## This resource will translate between Trenchbroom classnames and Godot scripts/scenes. See [url=https://qodotplugin.github.io/docs/entities/]Entities[/url] in the Qodot manual.
@export var entity_fgd: QodotFGDFile = load(\"res://addons/qodot/game_definitions/fgd/qodot_fgd.tres\")
@export_category(\"Textures\")
## Base directory for textures. When building materials, Qodot will search this directory for texture files matching the textures assigned to Trenchbroom faces.
@export_dir var base_texture_dir := \"res://textures\"
## File extensions to search for texture data.
@export var texture_file_extensions := PackedStringArray([\"png\", \"jpg\", \"jpeg\", \"bmp\"])
## Optional. List of worldspawn layers.
## A worldspawn layer converts any brush of a certain texture to a certain kind of node. See example 1-2.
@export var worldspawn_layers: Array[QodotWorldspawnLayer]
## Optional. Path for the clip texture, relative to [member base_texture_dir].
## Brushes textured with the clip texture will be turned into invisible but solid volumes.
@export var brush_clip_texture := \"special/clip\"
## Optional. Path for the skip texture, relative to [member base_texture_dir].
## Faces textured with the skip texture will not be rendered.
@export var face_skip_texture := \"special/skip\"
## Optional. WAD files to pull textures from.
## Quake engine games are distributed with .WAD files, which are packed texture libraries. Qodot can import these files as [QuakeWadFile]s.
@export var texture_wads: Array[QuakeWadFile]
@export_category(\"Materials\")
## File extensions to search for Material definitions
@export var material_file_extension := \"tres\"
## If true, all materials will be unshaded, i.e. will ignore light. Also known as \"fullbright\".
@export var unshaded := false
## Material used as template when generating missing materials.
@export var default_material : Material = StandardMaterial3D.new()
## Default albedo texture (used when [member default_material] is a [ShaderMaterial])
@export var default_material_albedo_uniform := \"\"
@export_category(\"UV Unwrap\")
## Texel size for UV2 unwrapping.
## A texel size of 1 will lead to a 1:1 correspondence between texture texels and lightmap texels. Larger values will produce less detailed lightmaps. To conserve memory and filesize, use the largest value that still looks good.
@export var uv_unwrap_texel_size := 1.0
@export_category(\"Build\")
## If true, print profiling data before and after each build step
@export var print_profiling_data := false
## If true, Qodot will build a hierarchy from Trenchbroom groups, each group being a node. Otherwise, Qodot nodes will ignore Trenchbroom groups and have a flat structure.
@export var use_trenchbroom_group_hierarchy := false
## If true, stop the whole editor until build is complete
@export var block_until_complete := false
## How many nodes to set the owner of, or add children of, at once. Higher values may lead to quicker build times, but a less responsive editor.
@export var set_owner_batch_size := 1000

# Build context variables
var qodot = null

var profile_timestamps := {}

var add_child_array := []
var set_owner_array := []

var should_add_children := true
var should_set_owners := true

var texture_list := []
var texture_loader = null
var texture_dict := {}
var texture_size_dict := {}
var material_dict := {}
var entity_definitions := {}
var entity_dicts := []
var worldspawn_layer_dicts := []
var entity_mesh_dict := {}
var worldspawn_layer_mesh_dict := {}
var entity_nodes := []
var worldspawn_layer_nodes := []
var entity_mesh_instances := {}
var entity_occluder_instances := {}
var worldspawn_layer_mesh_instances := {}
var entity_collision_shapes := []
var worldspawn_layer_collision_shapes := []

# Overrides
func _ready() -> void:
	if not DEBUG:
		return
	
	if not Engine.is_editor_hint():
		if verify_parameters():
			build_map()

# Utility
## Verify that Qodot is functioning and that [member map_file] exists. If so, build the map. If not, signal [signal build_failed]
func verify_and_build():
	if verify_parameters():
		build_map()
	else:
		emit_signal(\"build_failed\")

## Build the map.
func manual_build():
	should_add_children = false
	should_set_owners = false
	verify_and_build()

## Return true if parameters are valid; Qodot should be functioning and [member map_file] should exist.
func verify_parameters():
	if not qodot or DEBUG:
		qodot = load(\"res://addons/qodot/src/core/qodot.gd\").new()
	
	if not qodot:
		push_error(\"Error: Failed to load qodot.\")
		return false
	
	if map_file == \"\":
		push_error(\"Error: Map file not set\")
		return false
	
	if not FileAccess.file_exists(map_file):
		push_error(\"Error: No such file %s\" % map_file)
		return false
	
	return true

## Reset member variables that affect the current build
func reset_build_context():
	add_child_array = []
	set_owner_array = []
	
	texture_list = []
	texture_loader = null
	texture_dict = {}
	texture_size_dict = {}
	material_dict = {}
	entity_definitions = {}
	entity_dicts = []
	worldspawn_layer_dicts = []
	entity_mesh_dict = {}
	worldspawn_layer_mesh_dict = {}
	entity_nodes = []
	worldspawn_layer_nodes = []
	entity_mesh_instances = {}
	entity_occluder_instances = {}
	worldspawn_layer_mesh_instances = {}
	entity_collision_shapes = []
	worldspawn_layer_collision_shapes = []
	
	build_step_index = 0
	build_step_count = 0
	
	if qodot:
		qodot = load(\"res://addons/qodot/src/core/qodot.gd\").new()
		
## Record the start time of a build step for profiling
func start_profile(item_name: String) -> void:
	if print_profiling_data:
		print(item_name)
		profile_timestamps[item_name] = Time.get_unix_time_from_system()

## Finish profiling for a build step; print associated timing data
func stop_profile(item_name: String) -> void:
	if print_profiling_data:
		if item_name in profile_timestamps:
			var delta: float = Time.get_unix_time_from_system() - profile_timestamps[item_name]
			print(\"Done in %s sec.\\n\" % snapped(delta, 0.01))
			profile_timestamps.erase(item_name)

## Run a build step. [code]step_name[/code] is the method corresponding to the step, [code]params[/code] are parameters to pass to the step, and [code]func_name[/code] does nothing.
func run_build_step(step_name: String, params: Array = [], func_name: String = \"\"):
	start_profile(step_name)
	if func_name == \"\":
		func_name = step_name
	var result = callv(step_name, params)
	stop_profile(step_name)
	return result

## Add [code]node[/code] as a child of parent, or as a child of [code]below[/code] if non-null. Also queue for ownership assignment.
func add_child_editor(parent, node, below = null) -> void:
	var prev_parent = node.get_parent()
	if prev_parent:
		prev_parent.remove_child(node)
	
	if below:
		below.add_sibling(node)
	else:
		parent.add_child(node)
	
	set_owner_array.append(node)

## Set the owner of [code]node[/code] to the current scene.
func set_owner_editor(node):
	var tree := get_tree()
	
	if not tree:
		return
	
	var edited_scene_root := tree.get_edited_scene_root()
	
	if not edited_scene_root:
		return
	
	node.set_owner(edited_scene_root)

var build_step_index := 0
var build_step_count := 0
var build_steps := []
var post_attach_steps := []

## Register a build step.
## [code]build_step[/code] is a string that corresponds to a method on this class, [code]arguments[/code] a list of arguments to pass to this method, and [code]target[/code] is a property on this class to save the return value of the build step in. If [code]post_attach[/code] is true, the step will be run after the scene hierarchy is completed.
func register_build_step(build_step: String, arguments := [], target := \"\", post_attach := false) -> void:
	(post_attach_steps if post_attach else build_steps).append([build_step, arguments, target])
	build_step_count += 1

## Run all build steps. Emits [signal build_progress] after each step.
## If [code]post_attach[/code] is true, run post-attach steps instead and signal [signal build_complete] when finished.
func run_build_steps(post_attach := false) -> void:
	var target_array = post_attach_steps if post_attach else build_steps
	
	while target_array.size() > 0:
		var build_step = target_array.pop_front()
		emit_signal(\"build_progress\", build_step[0], float(build_step_index + 1) / float(build_step_count))
		
		var scene_tree := get_tree()
		if scene_tree and not block_until_complete:
			await get_tree().create_timer(YIELD_DURATION).timeout
		
		var result = run_build_step(build_step[0], build_step[1])
		var target = build_step[2]
		if target != \"\":
			set(target, result)
			
		build_step_index += 1
		
		if scene_tree and not block_until_complete:
			await get_tree().create_timer(YIELD_DURATION).timeout

	if post_attach:
		_build_complete()
	else:
		start_profile('add_children')
		add_children()

## Register all steps for the build. See [method register_build_step] and [method run_build_steps]
func register_build_steps() -> void:
	register_build_step('remove_children')
	register_build_step('load_map')
	register_build_step('fetch_texture_list', [], 'texture_list')
	register_build_step('init_texture_loader', [], 'texture_loader')
	register_build_step('load_textures', [], 'texture_dict')
	register_build_step('build_texture_size_dict', [], 'texture_size_dict')
	register_build_step('build_materials', [], 'material_dict')
	register_build_step('fetch_entity_definitions', [], 'entity_definitions')
	register_build_step('set_qodot_entity_definitions', [])
	register_build_step('set_qodot_worldspawn_layers', [])
	register_build_step('generate_geometry', [])
	register_build_step('fetch_entity_dicts', [], 'entity_dicts')
	register_build_step('fetch_worldspawn_layer_dicts', [], 'worldspawn_layer_dicts')
	register_build_step('build_entity_nodes', [], 'entity_nodes')
	register_build_step('build_worldspawn_layer_nodes', [], 'worldspawn_layer_nodes')
	register_build_step('resolve_group_hierarchy', [])
	register_build_step('build_entity_mesh_dict', [], 'entity_mesh_dict')
	register_build_step('build_worldspawn_layer_mesh_dict', [], 'worldspawn_layer_mesh_dict')
	register_build_step('build_entity_mesh_instances', [], 'entity_mesh_instances')
	register_build_step('build_entity_occluder_instances', [], 'entity_occluder_instances')
	register_build_step('build_worldspawn_layer_mesh_instances', [], 'worldspawn_layer_mesh_instances')
	register_build_step('build_entity_collision_shape_nodes', [], 'entity_collision_shapes')
	register_build_step('build_worldspawn_layer_collision_shape_nodes', [], 'worldspawn_layer_collision_shapes')

## Register all post-attach steps for the build. See [method register_build_step] and [method run_build_steps]
func register_post_attach_steps() -> void:
	register_build_step('build_entity_collision_shapes', [], \"\", true)
	register_build_step('build_worldspawn_layer_collision_shapes', [], \"\", true)
	register_build_step('apply_entity_meshes', [], \"\", true)
	register_build_step('apply_entity_occluders', [], \"\", true)
	register_build_step('apply_worldspawn_layer_meshes', [], \"\", true)
	register_build_step('apply_properties', [], \"\", true)
	register_build_step('connect_signals', [], \"\", true)
	register_build_step('remove_transient_nodes', [], \"\", true)

# Actions
## Build the map
func build_map() -> void:
	reset_build_context()
	
	print('Building %s\\n' % map_file)
	start_profile('build_map')
	
	register_build_steps()
	register_post_attach_steps()
	
	run_build_steps()

## Recursively unwrap UV2s for [code]node[/code] and its children, in preparation for baked lighting.
func unwrap_uv2(node: Node = null) -> void:
	var target_node = null
	
	if node:
		target_node = node
	else:
		target_node = self
		print(\"Unwrapping mesh UV2s\")
	
	if target_node is MeshInstance3D:
		var mesh = target_node.get_mesh()
		if mesh is ArrayMesh:
			mesh.lightmap_unwrap(Transform3D.IDENTITY, uv_unwrap_texel_size / inverse_scale_factor)
	
	for child in target_node.get_children():
		unwrap_uv2(child)
	
	if not node:
		print(\"Unwrap complete\")
		emit_signal(\"unwrap_uv2_complete\")

# Build Steps
## Recursively remove and delete all children of this node
func remove_children() -> void:
	for child in get_children():
		remove_child(child)
		child.queue_free()

## Parse and load [member map_file]
func load_map() -> void:
	var file: String = map_file
	qodot.load_map(file)

## Get textures found in [member map_file]
func fetch_texture_list() -> Array:
	return qodot.get_texture_list() as Array

## Initialize texture loader, allowing textures in [member base_texture_dir] and [member texture_wads] to be turned into materials
func init_texture_loader() -> QodotTextureLoader:
	var tex_ldr := QodotTextureLoader.new(
		base_texture_dir,
		texture_file_extensions,
		texture_wads
	)
	tex_ldr.unshaded = unshaded
	return tex_ldr

## Build a dictionary from Trenchbroom texture names to their corresponding Texture2D resources in Godot
func load_textures() -> Dictionary:
	return texture_loader.load_textures(texture_list) as Dictionary

## Build a dictionary from Trenchbroom texture names to Godot materials
func build_materials() -> Dictionary:
	return texture_loader.create_materials(texture_list, material_file_extension, default_material, default_material_albedo_uniform)

## Collect entity definitions from [member entity_fgd], as a dictionary from Trenchbroom classnames to entity definitions
func fetch_entity_definitions() -> Dictionary:
	return entity_fgd.get_entity_definitions()

## Hand the Qodot C# core the entity definitions
func set_qodot_entity_definitions() -> void:
	qodot.set_entity_definitions(build_libmap_entity_definitions(entity_definitions))

## Hand the Qodot C# core the worldspawn layer definitions. See [member worldspawn_layers]
func set_qodot_worldspawn_layers() -> void:
	qodot.set_worldspawn_layers(build_libmap_worldspawn_layers(worldspawn_layers))

## Generate geometry from map file
func generate_geometry() -> void:
	qodot.generate_geometry(texture_size_dict);

## Get a list of dictionaries representing each entity from the Qodot C# core
func fetch_entity_dicts() -> Array:
	return qodot.get_entity_dicts()

## Get a list of dictionaries representing each worldspawn layer from the Qodot C# core
func fetch_worldspawn_layer_dicts() -> Array:
	var layer_dicts = qodot.get_worldspawn_layer_dicts()
	return layer_dicts if layer_dicts else []

## Build a dictionary from Trenchbroom textures to the sizes of their corresponding Godot textures
func build_texture_size_dict() -> Dictionary:
	var texture_size_dict := {}
	
	for tex_key in texture_dict:
		var texture := texture_dict[tex_key] as Texture2D
		if texture:
			texture_size_dict[tex_key] = texture.get_size()
		else:
			texture_size_dict[tex_key] = Vector2.ONE
	
	return texture_size_dict

## Marshall Qodot FGD definitions for transfer to libmap
func build_libmap_entity_definitions(entity_definitions: Dictionary) -> Dictionary:
	var libmap_entity_definitions = {}
	for classname in entity_definitions:
		libmap_entity_definitions[classname] = {}
		if entity_definitions[classname] is QodotFGDSolidClass:
			libmap_entity_definitions[classname]['spawn_type'] = entity_definitions[classname].spawn_type
	return libmap_entity_definitions

## Marshall worldspawn layer definitions for transfer to libmap
func build_libmap_worldspawn_layers(worldspawn_layers: Array) -> Array:
	var libmap_worldspawn_layers := []
	for worldspawn_layer in worldspawn_layers:
		libmap_worldspawn_layers.append({
			'name': worldspawn_layer.name,
			'texture': worldspawn_layer.texture,
			'node_class': worldspawn_layer.node_class,
			'build_visuals': worldspawn_layer.build_visuals,
			'collision_shape_type': worldspawn_layer.collision_shape_type,
			'script_class': worldspawn_layer.script_class
		})
	return libmap_worldspawn_layers

## Build nodes from the entities in [member entity_dicts]
func build_entity_nodes() -> Array:
	var entity_nodes := []

	for entity_idx in range(0, entity_dicts.size()):
		var entity_dict := entity_dicts[entity_idx] as Dictionary
		var properties := entity_dict['properties'] as Dictionary
		
		var node = QodotEntity.new()
		var node_name = \"entity_%s\" % entity_idx
		
		var should_add_child = should_add_children
		
		if 'classname' in properties:
			var classname = properties['classname']
			node_name += \"_\" + classname
			if classname in entity_definitions:
				var entity_definition := entity_definitions[classname] as QodotFGDClass
				if entity_definition is QodotFGDSolidClass:
					if entity_definition.spawn_type == QodotFGDSolidClass.SpawnType.MERGE_WORLDSPAWN:
						entity_nodes.append(null)
						continue
					elif use_trenchbroom_group_hierarchy and entity_definition.spawn_type == QodotFGDSolidClass.SpawnType.GROUP:
						should_add_child = false
					if entity_definition.node_class != \"\":
						node.queue_free()
						node = ClassDB.instantiate(entity_definition.node_class)
				elif entity_definition is QodotFGDPointClass:
					if entity_definition.scene_file:
						var flag = PackedScene.GEN_EDIT_STATE_DISABLED
						if Engine.is_editor_hint():
							flag = PackedScene.GEN_EDIT_STATE_INSTANCE
						node.queue_free()
						node = entity_definition.scene_file.instantiate(flag)
					elif entity_definition.node_class != \"\":
						node.queue_free()
						node = ClassDB.instantiate(entity_definition.node_class)
					if 'rotation_degrees' in node and entity_definition.apply_rotation_on_map_build:
						var angles := Vector3.ZERO
						if 'angles' in properties or 'mangle' in properties:
							var key := 'angles' if 'angles' in properties else 'mangle'
							var angles_raw = properties[key]
							if not angles_raw is Vector3:
								angles_raw = angles_raw.split_floats(' ')
							if angles_raw.size() > 2:
								angles = Vector3(-angles_raw[0], angles_raw[1], -angles_raw[2])
								if key == 'mangle':
									if entity_definition.classname.begins_with('light'):
										angles = Vector3(angles_raw[1], angles_raw[0], -angles_raw[2])
									elif entity_definition.classname == 'info_intermission':
										angles = Vector3(angles_raw[0], angles_raw[1], -angles_raw[2])
							else:
								push_error(\"Invalid vector format for \\'\" + key + \"\\' in entity \\'\" + classname + \"\\'\")
						elif 'angle' in properties:
							var angle = properties['angle']
							if not angle is float:
								angle = float(angle)
							angles.y += angle
						angles.y += 180
						node.rotation_degrees = angles
				if entity_definition.script_class:
					node.set_script(entity_definition.script_class)
		
		node.name = node_name
		
		if 'origin' in properties:
			var origin_vec = Vector3.ZERO
			var origin_comps = properties['origin'].split_floats(' ')
			if origin_comps.size() > 2:
				origin_vec = Vector3(origin_comps[1], origin_comps[2], origin_comps[0])
			else:
				push_error(\"Invalid vector format for \\'origin\\' in \" + node.name)
			if \"position\" in node:
				if node.position is Vector3:
					node.position = origin_vec / inverse_scale_factor
				elif node.position is Vector2:
					node.position = Vector2(origin_vec.z, -origin_vec.y)
		else:
			if entity_idx != 0 and \"position\" in node:
				if node.position is Vector3:
					node.position = entity_dict['center'] / inverse_scale_factor
		
		entity_nodes.append(node)
		
		if should_add_child:
			queue_add_child(self, node)
	
	return entity_nodes

## Build nodes from the worldspawn layers in [member worldspawn_layers]
func build_worldspawn_layer_nodes() -> Array:
	var worldspawn_layer_nodes := []
	
	for worldspawn_layer in worldspawn_layers:
		var node = ClassDB.instantiate(worldspawn_layer.node_class)
		node.name = \"entity_0_\" + worldspawn_layer.name
		if worldspawn_layer.script_class:
			node.set_script(worldspawn_layer.script_class)
		
		worldspawn_layer_nodes.append(node)
		queue_add_child(self, node, entity_nodes[0])
	
	return worldspawn_layer_nodes

## Resolve entity group hierarchy, turning Trenchbroom groups into nodes and queueing their contents to be added to said nodes as children
func resolve_group_hierarchy() -> void:
	if not use_trenchbroom_group_hierarchy:
		return
	
	var group_entities := {}
	var owner_entities := {}
	
	# Gather group entities and their owning children
	for node_idx in range(0, entity_nodes.size()):
		var node = entity_nodes[node_idx]
		var properties = entity_dicts[node_idx]['properties']
		
		if not properties: continue
		
		if not '_tb_id' in properties and not '_tb_group' in properties:
			continue
		
		if not 'classname' in properties: continue
		var classname = properties['classname']
		
		if not classname in entity_definitions: continue
		var entity_definition = entity_definitions[classname]
		# TODO: Add clause on this line for point entities, which do not have a spawn type. Add as child of the current group owner.
		if entity_definition.spawn_type == QodotFGDSolidClass.SpawnType.GROUP:
			group_entities[node_idx] = node
		else:
			owner_entities[node_idx] = node
	
	var group_to_entity_map := {}
	
	for node_idx in owner_entities:
		var node = owner_entities[node_idx]
		var properties = entity_dicts[node_idx]['properties']
		var tb_group = properties['_tb_group']
		
		var parent_idx = null
		var parent = null
		var parent_properties = null
		for group_idx in group_entities:
			var group_entity = group_entities[group_idx]
			var group_properties = entity_dicts[group_idx]['properties']
			if group_properties['_tb_id'] == tb_group:
				parent_idx = group_idx
				parent = group_entity
				parent_properties = group_properties
				break
		
		if parent:
			group_to_entity_map[parent_idx] = node_idx
	
	var group_to_group_map := {}
	
	for node_idx in group_entities:
		var node = group_entities[node_idx]
		var properties = entity_dicts[node_idx]['properties']
		
		if not '_tb_group' in properties:
			continue
		
		var tb_group = properties['_tb_group']
		
		var parent_idx = null
		var parent = null
		var parent_properties = null
		for group_idx in group_entities:
			var group_entity = group_entities[group_idx]
			var group_properties = entity_dicts[group_idx]['properties']
			if group_properties['_tb_id'] == tb_group:
				parent_idx = group_idx
				parent = group_entity
				parent_properties = group_properties
				break
		
		if parent:
			group_to_group_map[parent_idx] = node_idx
	
	for parent_idx in group_to_group_map:
		var child_idx = group_to_group_map[parent_idx]
		
		var parent_entity_idx = group_to_entity_map[parent_idx]
		var child_entity_idx = group_to_entity_map[child_idx]
		
		var parent = entity_nodes[parent_entity_idx]
		var child = entity_nodes[child_entity_idx]
		
		queue_add_child(parent, child, null, true)
	
	for child_idx in group_to_entity_map:
		var parent_idx = group_to_entity_map[child_idx]
		
		var parent = entity_nodes[parent_idx]
		var child = entity_nodes[child_idx]
		
		queue_add_child(parent, child, null, true)

## Return the node associated with a Trenchbroom index. Unused.
func get_node_by_tb_id(target_id: String, entity_nodes: Dictionary):
	for node_idx in entity_nodes:
		var node = entity_nodes[node_idx]
		
		if not node:
			continue
		
		if not 'properties' in node:
			continue
		
		var properties = node['properties']
		
		if not '_tb_id' in properties:
			continue
		
		var parent_id = properties['_tb_id']
		if parent_id == target_id:
			return node
		
	return null

## Build [CollisionShape3D] nodes for brush entities
func build_entity_collision_shape_nodes() -> Array:
	var entity_collision_shapes_arr := []
	
	for entity_idx in range(0, entity_nodes.size()):
		var entity_collision_shapes := []
		
		var entity_dict = entity_dicts[entity_idx]
		var properties = entity_dict['properties']
		
		var node := entity_nodes[entity_idx] as Node
		var concave = false
		
		if 'classname' in properties:
			var classname = properties['classname']
			if classname in entity_definitions:
				var entity_definition := entity_definitions[classname] as QodotFGDSolidClass
				if entity_definition:
					if entity_definition.collision_shape_type == QodotFGDSolidClass.CollisionShapeType.NONE:
						entity_collision_shapes_arr.append(null)
						continue
					elif entity_definition.collision_shape_type == QodotFGDSolidClass.CollisionShapeType.CONCAVE:
						concave = true
					
					if entity_definition.spawn_type == QodotFGDSolidClass.SpawnType.MERGE_WORLDSPAWN:
						# TODO: Find the worldspawn object instead of assuming index 0
						node = entity_nodes[0] as Node
					
					if node and node is CollisionObject3D:
						(node as CollisionObject3D).collision_layer = entity_definition.collision_layer
						(node as CollisionObject3D).collision_mask = entity_definition.collision_mask
						(node as CollisionObject3D).collision_priority = entity_definition.collision_priority
		
		# don't create collision shapes that wont be attached to a CollisionObject3D as they are a waste
		if not node or (not node is CollisionObject3D):
			entity_collision_shapes_arr.append(null)
			continue
		
		if concave:
			var collision_shape := CollisionShape3D.new()
			collision_shape.name = \"entity_%s_collision_shape\" % entity_idx
			entity_collision_shapes.append(collision_shape)
			queue_add_child(node, collision_shape)
		else:
			for brush_idx in entity_dict['brush_indices']:
				var collision_shape := CollisionShape3D.new()
				collision_shape.name = \"entity_%s_brush_%s_collision_shape\" % [entity_idx, brush_idx]
				entity_collision_shapes.append(collision_shape)
				queue_add_child(node, collision_shape)
		entity_collision_shapes_arr.append(entity_collision_shapes)
	
	return entity_collision_shapes_arr

## Build CollisionShape3D nodes for worldspawn layers
func build_worldspawn_layer_collision_shape_nodes() -> Array:
	var worldspawn_layer_collision_shapes := []
	
	for layer_idx in range(0, worldspawn_layers.size()):
		if layer_idx >= worldspawn_layer_dicts.size():
			continue
		
		var layer = worldspawn_layers[layer_idx]
		
		var layer_dict = worldspawn_layer_dicts[layer_idx]
		var node := worldspawn_layer_nodes[layer_idx] as Node
		var concave = false
		
		var shapes := []
		
		if layer.collision_shape_type == QodotFGDSolidClass.CollisionShapeType.NONE:
			worldspawn_layer_collision_shapes.append(shapes)
			continue
		elif layer.collision_shape_type == QodotFGDSolidClass.CollisionShapeType.CONCAVE:
			concave = true
		
		if not node:
			worldspawn_layer_collision_shapes.append(shapes)
			continue
		
		if concave:
			var collision_shape := CollisionShape3D.new()
			collision_shape.name = \"entity_0_%s_collision_shape\" % layer.name
			shapes.append(collision_shape)
			queue_add_child(node, collision_shape)
		else:
			for brush_idx in layer_dict['brush_indices']:
				var collision_shape := CollisionShape3D.new()
				collision_shape.name = \"entity_0_%s_brush_%s_collision_shape\" % [layer.name, brush_idx]
				shapes.append(collision_shape)
				queue_add_child(node, collision_shape)
		
		worldspawn_layer_collision_shapes.append(shapes)
	
	return worldspawn_layer_collision_shapes

## Build the concrete [Shape3D] resources for each brush
func build_entity_collision_shapes() -> void:
	for entity_idx in range(0, entity_dicts.size()):
		var entity_dict := entity_dicts[entity_idx] as Dictionary
		var properties = entity_dict['properties']
		var entity_position: Vector3 = Vector3.ZERO
		if entity_nodes[entity_idx] != null and entity_nodes[entity_idx].get(\"position\"):
			if entity_nodes[entity_idx].position is Vector3:
				entity_position = entity_nodes[entity_idx].position
		var entity_collision_shape = entity_collision_shapes[entity_idx]
		
		if entity_collision_shape == null:
			continue
		
		var concave: bool = false
		var shape_margin: float = 0.04
		
		if 'classname' in properties:
			var classname = properties['classname']
			if classname in entity_definitions:
				var entity_definition = entity_definitions[classname] as QodotFGDSolidClass
				if entity_definition:
					match(entity_definition.collision_shape_type):
						QodotFGDSolidClass.CollisionShapeType.NONE:
							continue
						QodotFGDSolidClass.CollisionShapeType.CONVEX:
							concave = false
						QodotFGDSolidClass.CollisionShapeType.CONCAVE:
							concave = true
					shape_margin = entity_definition.collision_shape_margin
		
		if entity_collision_shapes[entity_idx] == null:
			continue
		
		if concave:
			qodot.gather_entity_concave_collision_surfaces(entity_idx, face_skip_texture)
		else:
			qodot.gather_entity_convex_collision_surfaces(entity_idx)
		
		var entity_surfaces := qodot.fetch_surfaces(inverse_scale_factor) as Array
		
		var entity_verts := PackedVector3Array()
		
		for surface_idx in range(0, entity_surfaces.size()):
			var surface_verts = entity_surfaces[surface_idx]
			
			if surface_verts == null:
				continue
			
			if concave:
				var vertices := surface_verts[Mesh.ARRAY_VERTEX] as PackedVector3Array
				var indices := surface_verts[Mesh.ARRAY_INDEX] as PackedInt32Array
				for vert_idx in indices:
					entity_verts.append(vertices[vert_idx])
			else:
				var shape_points = PackedVector3Array()
				for vertex in surface_verts[Mesh.ARRAY_VERTEX]:
					if not vertex in shape_points:
						shape_points.append(vertex)
				
				var shape = ConvexPolygonShape3D.new()
				shape.set_points(shape_points)
				shape.margin = shape_margin
				
				var collision_shape = entity_collision_shape[surface_idx]
				collision_shape.set_shape(shape)
				
		if concave:
			if entity_verts.size() == 0:
				continue
			
			var shape = ConcavePolygonShape3D.new()
			shape.set_faces(entity_verts)
			shape.margin = shape_margin
			
			var collision_shape = entity_collision_shapes[entity_idx][0]
			collision_shape.set_shape(shape)

## Build the concrete [Shape3D] resources for each worldspawn layer
func build_worldspawn_layer_collision_shapes() -> void:
	for layer_idx in range(0, worldspawn_layers.size()):
		if layer_idx >= worldspawn_layer_dicts.size():
			continue
		
		var layer = worldspawn_layers[layer_idx]
		var concave = false
		
		match(layer.collision_shape_type):
			QodotFGDSolidClass.CollisionShapeType.NONE:
				continue
			QodotFGDSolidClass.CollisionShapeType.CONVEX:
				concave = false
			QodotFGDSolidClass.CollisionShapeType.CONCAVE:
				concave = true
		
		var layer_dict = worldspawn_layer_dicts[layer_idx]
		
		if not worldspawn_layer_collision_shapes[layer_idx]:
			continue
		
		qodot.gather_worldspawn_layer_collision_surfaces(0)
		
		var layer_surfaces := qodot.FetchSurfaces(inverse_scale_factor) as Array
		
		var verts := PackedVector3Array()
		
		for i in range(0, layer_dict.brush_indices.size()):
			var surface_idx = layer_dict.brush_indices[i]
			var surface_verts = layer_surfaces[surface_idx]
			
			if not surface_verts:
				continue
			
			if concave:
				var vertices := surface_verts[0] as PackedVector3Array
				var indices := surface_verts[8] as PackedInt32Array
				for vert_idx in indices:
					verts.append(vertices[vert_idx])
			else:
				var shape_points = PackedVector3Array()
				for vertex in surface_verts[0]:
					if not vertex in shape_points:
						shape_points.append(vertex)
				
				var shape = ConvexPolygonShape3D.new()
				shape.set_points(shape_points)
				
				var collision_shape = worldspawn_layer_collision_shapes[layer_idx][i]
				collision_shape.set_shape(shape)
		
		if concave:
			if verts.size() == 0:
				continue
			
			var shape = ConcavePolygonShape3D.new()
			shape.set_faces(verts)
			
			var collision_shape = worldspawn_layer_collision_shapes[layer_idx][0]
			collision_shape.set_shape(shape)

## Build Dictionary from entity indices to [ArrayMesh] instances
func build_entity_mesh_dict() -> Dictionary:
	var meshes := {}
	
	var texture_surf_map: Dictionary
	for texture in texture_dict:
		texture_surf_map[texture] = Array()
	
	var gather_task = func(i):
		var texture = texture_dict.keys()[i]
		texture_surf_map[texture] = qodot.gather_texture_surfaces_mt(texture, brush_clip_texture, face_skip_texture, inverse_scale_factor)
	
	var task_id:= WorkerThreadPool.add_group_task(gather_task, texture_dict.keys().size(), 4, true)
	WorkerThreadPool.wait_for_group_task_completion(task_id)
	
	for texture in texture_dict:
		var texture_surfaces := texture_surf_map[texture] as Array
		
		for entity_idx in range(0, texture_surfaces.size()):
			var entity_dict := entity_dicts[entity_idx] as Dictionary
			var properties = entity_dict['properties']
			
			var entity_surface = texture_surfaces[entity_idx]
			
			if 'classname' in properties:
				var classname = properties['classname']
				if classname in entity_definitions:
					var entity_definition = entity_definitions[classname] as QodotFGDSolidClass
					if entity_definition:
						if entity_definition.spawn_type == QodotFGDSolidClass.SpawnType.MERGE_WORLDSPAWN:
							entity_surface = null
							
						if not entity_definition.build_visuals and not entity_definition.build_occlusion:
							entity_surface = null
						
			if entity_surface == null:
				continue
			
			if not entity_idx in meshes:
				meshes[entity_idx] = ArrayMesh.new()
			
			var mesh: ArrayMesh = meshes[entity_idx]
			mesh.add_surface_from_arrays(ArrayMesh.PRIMITIVE_TRIANGLES, entity_surface)
			mesh.surface_set_name(mesh.get_surface_count() - 1, texture)
			mesh.surface_set_material(mesh.get_surface_count() - 1, material_dict[texture])
	
	return meshes

## Build Dictionary from worldspawn layers (via textures) to [ArrayMesh] instances
func build_worldspawn_layer_mesh_dict() -> Dictionary:
	var meshes := {}
	
	for layer in worldspawn_layer_dicts:
		var texture = layer.texture
		qodot.gather_worldspawn_layer_surfaces(texture, brush_clip_texture, face_skip_texture)
		var texture_surfaces := qodot.fetch_surfaces(inverse_scale_factor) as Array
		
		var mesh: Mesh = null
		if not texture in meshes:
			meshes[texture] = ArrayMesh.new()
		
		mesh = meshes[texture]
		mesh.add_surface_from_arrays(ArrayMesh.PRIMITIVE_TRIANGLES, texture_surfaces[0])
		mesh.surface_set_name(mesh.get_surface_count() - 1, texture)
		mesh.surface_set_material(mesh.get_surface_count() - 1, material_dict[texture])
	
	return meshes

## Build [MeshInstance3D]s from brush entities and add them to the add child queue
func build_entity_mesh_instances() -> Dictionary:
	var entity_mesh_instances := {}
	for entity_idx in entity_mesh_dict:
		var use_in_baked_light = false
		var shadow_casting_setting := GeometryInstance3D.SHADOW_CASTING_SETTING_DOUBLE_SIDED
		var render_layers: int = 1
		
		var entity_dict := entity_dicts[entity_idx] as Dictionary
		var properties = entity_dict['properties']
		var classname = properties['classname']
		if classname in entity_definitions:
			var entity_definition = entity_definitions[classname] as QodotFGDSolidClass
			if entity_definition:
				if not entity_definition.build_visuals:
					continue
				
				if entity_definition.use_in_baked_light:
					use_in_baked_light = true
				elif '_shadow' in properties:
					if properties['_shadow'] == \"1\":
						use_in_baked_light = true
				shadow_casting_setting = entity_definition.shadow_casting_setting
				render_layers = entity_definition.render_layers
		
		if not entity_mesh_dict[entity_idx]:
			continue
		
		var mesh_instance := MeshInstance3D.new()
		mesh_instance.name = 'entity_%s_mesh_instance' % entity_idx
		mesh_instance.gi_mode = MeshInstance3D.GI_MODE_STATIC if use_in_baked_light else GeometryInstance3D.GI_MODE_DISABLED
		mesh_instance.cast_shadow = shadow_casting_setting
		mesh_instance.layers = render_layers
		
		queue_add_child(entity_nodes[entity_idx], mesh_instance)
		
		entity_mesh_instances[entity_idx] = mesh_instance
	
	return entity_mesh_instances

func build_entity_occluder_instances() -> Dictionary:
	var entity_occluder_instances := {}
	for entity_idx in entity_mesh_dict:
		var entity_dict := entity_dicts[entity_idx] as Dictionary
		var properties = entity_dict['properties']
		var classname = properties['classname']
		if classname in entity_definitions:
			var entity_definition = entity_definitions[classname] as QodotFGDSolidClass
			if entity_definition:
				if entity_definition.build_occlusion:
					if not entity_mesh_dict[entity_idx]:
						continue
					
					var occluder_instance := OccluderInstance3D.new()
					occluder_instance.name = 'entity_%s_occluder_instance' % entity_idx
					
					queue_add_child(entity_nodes[entity_idx], occluder_instance)
					entity_occluder_instances[entity_idx] = occluder_instance
	
	return entity_occluder_instances

## Build Dictionary from worldspawn layers (via textures) to [MeshInstance3D]s
func build_worldspawn_layer_mesh_instances() -> Dictionary:
	var worldspawn_layer_mesh_instances := {}
	var idx = 0
	for i in range(0, worldspawn_layers.size()):
		var worldspawn_layer = worldspawn_layers[i]
		var texture_name = worldspawn_layer.texture
		
		if not texture_name in worldspawn_layer_mesh_dict:
			continue
		
		var mesh := worldspawn_layer_mesh_dict[texture_name] as Mesh
		
		if not mesh:
			continue
		
		var mesh_instance := MeshInstance3D.new()
		mesh_instance.name = 'entity_0_%s_mesh_instance' % worldspawn_layer.name
		mesh_instance.gi_mode = MeshInstance3D.GI_MODE_STATIC
		
		queue_add_child(worldspawn_layer_nodes[idx], mesh_instance)
		idx += 1
		
		worldspawn_layer_mesh_instances[texture_name] = mesh_instance
	
	return worldspawn_layer_mesh_instances

## Assign [ArrayMesh]es to their [MeshInstance3D] counterparts
func apply_entity_meshes() -> void:
	for entity_idx in entity_mesh_instances:
		var mesh := entity_mesh_dict[entity_idx] as Mesh
		var mesh_instance := entity_mesh_instances[entity_idx] as MeshInstance3D
		if not mesh or not mesh_instance:
			continue
		
		mesh_instance.set_mesh(mesh)
		queue_add_child(entity_nodes[entity_idx], mesh_instance)

func apply_entity_occluders() -> void:
	for entity_idx in entity_mesh_dict:
		var mesh := entity_mesh_dict[entity_idx] as Mesh
		var occluder_instance : OccluderInstance3D
		
		if entity_idx in entity_occluder_instances:
			occluder_instance = entity_occluder_instances[entity_idx]
		
		if not mesh or not occluder_instance:
			continue
		
		var verts: PackedVector3Array
		var indices: PackedInt32Array
		for surf_idx in range(mesh.get_surface_count()):
			var vert_count := verts.size()
			var surf_array := mesh.surface_get_arrays(surf_idx)
			verts.append_array(surf_array[Mesh.ARRAY_VERTEX])
			indices.resize(indices.size() + surf_array[Mesh.ARRAY_INDEX].size())
			for new_index in surf_array[Mesh.ARRAY_INDEX]:
				indices.append(new_index + vert_count)
		
		var occluder := ArrayOccluder3D.new()
		occluder.set_arrays(verts, indices)
		
		occluder_instance.occluder = occluder
		
## Assign [ArrayMesh]es to their [MeshInstance3D] counterparts for worldspawn layers
func apply_worldspawn_layer_meshes() -> void:
	for texture_name in worldspawn_layer_mesh_dict:
		var mesh = worldspawn_layer_mesh_dict[texture_name]
		var mesh_instance = worldspawn_layer_mesh_instances[texture_name]
		
		if not mesh or not mesh_instance:
			continue
		
		mesh_instance.set_mesh(mesh)

## Add a child and its new parent to the add child queue. If [code]below[/code] is a node, add it as a child to that instead. If [code]relative[/code] is true, set the location of node relative to parent.
func queue_add_child(parent, node, below = null, relative = false) -> void:
	add_child_array.append({\"parent\": parent, \"node\": node, \"below\": below, \"relative\": relative})

## Assign children to parents based on the contents of the add child queue (see [method queue_add_child])
func add_children() -> void:
	while true:
		for i in range(0, set_owner_batch_size):
			var data = add_child_array.pop_front()
			if data:
				add_child_editor(data['parent'], data['node'], data['below'])
				if data['relative']:
					data['node'].global_transform.origin -= data['parent'].global_transform.origin
			else:
				add_children_complete()
				return
		
		var scene_tree := get_tree()
		if scene_tree and not block_until_complete:
			await get_tree().create_timer(YIELD_DURATION).timeout

## Set owners and start post-attach build steps
func add_children_complete():
	stop_profile('add_children')
	
	if should_set_owners:
		start_profile('set_owners')
		set_owners()
	else:
		run_build_steps(true)

## Set owner of nodes generated by Qodot to scene root based on [member set_owner_array]
func set_owners():
	while true:
		for i in range(0, set_owner_batch_size):
			var node = set_owner_array.pop_front()
			if node:
				set_owner_editor(node)
			else:
				set_owners_complete()
				return
				
		var scene_tree := get_tree()
		if scene_tree and not block_until_complete:
			await get_tree().create_timer(YIELD_DURATION).timeout

## Finish profiling for set_owners and start post-attach build steps
func set_owners_complete():
	stop_profile('set_owners')
	run_build_steps(true)

## Apply Trenchbroom properties to [QodotEntity] instances, transferring Trenchbroom dictionaries to [QodotEntity.properties]
func apply_properties() -> void:
	for entity_idx in range(0, entity_nodes.size()):
		var entity_node = entity_nodes[entity_idx]
		if not entity_node:
			continue
		
		var entity_dict := entity_dicts[entity_idx] as Dictionary
		var properties := entity_dict['properties'] as Dictionary
		
		if 'classname' in properties:
			var classname = properties['classname']
			if classname in entity_definitions:
				var entity_definition := entity_definitions[classname] as QodotFGDClass
				
				for property in properties:
					var prop_string = properties[property]
					if property in entity_definition.class_properties:
						var prop_default = entity_definition.class_properties[property]
						if prop_default is int:
							properties[property] = prop_string.to_int()
						elif prop_default is float:
							properties[property] = prop_string.to_float()
						elif prop_default is Vector3:
							var prop_comps = prop_string.split_floats(\" \")
							if prop_comps.size() > 2:
								properties[property] = Vector3(prop_comps[0], prop_comps[1], prop_comps[2])
							else:
								push_error(\"Invalid vector format for \\'\" + property + \"\\' in entity \\'\" + classname + \"\\': \" + prop_string)
								properties[property] = prop_default
						elif prop_default is Color:
							var prop_color = prop_default
							var prop_comps = prop_string.split(\" \")
							if prop_comps.size() > 2:
								if \".\" in prop_comps[0] or \".\" in prop_comps[1] or \".\" in prop_comps[2]:
									prop_color.r = prop_comps[0].to_float()
									prop_color.g = prop_comps[1].to_float()
									prop_color.b = prop_comps[2].to_float()
								else:
									prop_color.r8 = prop_comps[0].to_int()
									prop_color.g8 = prop_comps[1].to_int()
									prop_color.b8 = prop_comps[2].to_int()
							else:
								push_error(\"Invalid color format for \\'\" + property + \"\\' in entity \\'\" + classname + \"\\': \" + prop_string)
								
							properties[property] = prop_color
						elif prop_default is Dictionary:
							properties[property] = prop_string.to_int()
						elif prop_default is Array:
							properties[property] = prop_string.to_int()
				
				# Assign properties not defined with defaults from the entity definition
				for property in entity_definitions[classname].class_properties:
					if not property in properties:
						var prop_default = entity_definition.class_properties[property]
						# Flags
						if prop_default is Array:
							var prop_flags_sum := 0
							for prop_flag in prop_default:
								if prop_flag is Array and prop_flag.size() > 2:
									if prop_flag[2] and prop_flag[1] is int:
										prop_flags_sum += prop_flag[1]
							properties[property] = prop_flags_sum
						# Choices
						elif prop_default is Dictionary:
							var prop_desc = entity_definition.class_property_descriptions[property]
							if prop_desc is Array and prop_desc.size() > 1 and prop_desc[1] is int:
								properties[property] = prop_desc[1]
							else:
								properties[property] = 0
						# Everything else
						else:
							properties[property] = prop_default
						
		if 'properties' in entity_node:
			entity_node.properties = properties

## Wire signals based on Trenchbroom [code]target[/code] and [code]targetname[/code] properties
func connect_signals() -> void:
	for entity_idx in range(0, entity_nodes.size()):
		var entity_node = entity_nodes[entity_idx]
		if not entity_node:
			continue
		
		var entity_dict := entity_dicts[entity_idx] as Dictionary
		var entity_properties := entity_dict['properties'] as Dictionary
		
		if not 'target' in entity_properties:
			continue
		
		var target_nodes := get_nodes_by_targetname(entity_properties['target'])
		for target_node in target_nodes:
			connect_signal(entity_node, target_node)

## Connect a signal on [code]entity_node[/code] to [code]target_node[/code], possibly mediated by the contents of a [code]signal[/code] or [code]receiver[/code] entity
func connect_signal(entity_node: Node, target_node: Node) -> void:
	if target_node.properties['classname'] == 'signal':
		var signal_name = target_node.properties['signal_name']
		
		var receiver_nodes := get_nodes_by_targetname(target_node.properties['target'])
		for receiver_node in receiver_nodes:
			if receiver_node.properties['classname'] != 'receiver':
				continue
			
			var receiver_name = receiver_node.properties['receiver_name']
			
			var target_nodes := get_nodes_by_targetname(receiver_node.properties['target'])
			for node in target_nodes:
				entity_node.connect(signal_name,Callable(node,receiver_name),CONNECT_PERSIST)
	else:
		var signal_list = entity_node.get_signal_list()
		for signal_dict in signal_list:
			if signal_dict['name'] == 'trigger':
				entity_node.connect(\"trigger\",Callable(target_node,\"use\"),CONNECT_PERSIST)
				break

## Remove nodes marked transient. See [member QodotFGDClass.transient_node]
func remove_transient_nodes() -> void:
	for entity_idx in range(0, entity_nodes.size()):
		var entity_node = entity_nodes[entity_idx]
		if not entity_node:
			continue
		
		var entity_dict := entity_dicts[entity_idx] as Dictionary
		var entity_properties := entity_dict['properties'] as Dictionary
		
		if not 'classname' in entity_properties:
			continue
		
		var classname = entity_properties['classname']
		
		if not classname in entity_definitions:
			continue
		
		var entity_definition = entity_definitions[classname]
		if entity_definition.transient_node:
			entity_node.get_parent().remove_child(entity_node)
			entity_node.queue_free()

## Find all nodes with matching targetname property
func get_nodes_by_targetname(targetname: String) -> Array:
	var nodes := []
	
	for node_idx in range(0, entity_nodes.size()):
		var node = entity_nodes[node_idx]
		if not node:
			continue
		
		var entity_dict := entity_dicts[node_idx] as Dictionary
		var entity_properties := entity_dict['properties'] as Dictionary
		
		if not 'targetname' in entity_properties:
			continue
		
		if entity_properties['targetname'] == targetname:
			nodes.append(node)
	
	return nodes

# Cleanup after build is finished (internal)
func _build_complete():
	reset_build_context()
	
	stop_profile('build_map')
	if not print_profiling_data:
		print('\\n')
	print('Build complete\\n')
	
	emit_signal(\"build_complete\")
"

[sub_resource type="GDScript" id="GDScript_3gh3d"]
script/source = "@tool
class_name QodotFGDSolidClass
extends QodotFGDClass

enum SpawnType {
	WORLDSPAWN = 0, ## Is worldspawn
	MERGE_WORLDSPAWN = 1, ## Should be combined with worldspawn
	ENTITY = 2, ## Is its own separate entity
	GROUP = 3 ## Is a group
}

enum CollisionShapeType {
	NONE, ## Should have no collision shape
	CONVEX, ## Should have a convex collision shape
	CONCAVE ## Should have a concave collision shape
}

@export_group(\"Spawn\")
## Controls whether a given SolidClass is the worldspawn, is combined with the worldspawn, or is spawned as its own free-standing entity
@export var spawn_type: SpawnType = SpawnType.ENTITY

@export_group(\"Visual Build\")
## Controls whether a visual mesh is built for this SolidClass
@export var build_visuals := true
## Automatically unwrap the UV2 for lightmapping on build
@export var use_in_baked_light := true
## Shadow casting setting allows for further lightmapping customization
@export var shadow_casting_setting := GeometryInstance3D.SHADOW_CASTING_SETTING_ON
## Automatically build OccluderInstance3D for this entity
@export var build_occlusion := false
## This entity will only be visible for Camera3Ds whose cull mask includes any of the render layers this VisualInstance3D is set to
@export_flags_3d_render var render_layers: int = 1

@export_group(\"Collision Build\")
## Controls how collisions are built for this SolidClass
@export var collision_shape_type: CollisionShapeType = CollisionShapeType.CONVEX
## The physics layers this SolidClass is in.
@export_flags_3d_physics var collision_layer: int = 1
## The physics layers this SolidClass scans.
@export_flags_3d_physics var collision_mask: int = 1
## The priority used to solve colliding when occurring penetration. The higher the priority is, the lower the penetration into the SolidClass will be. This can for example be used to prevent the player from breaking through the boundaries of a level.
@export var collision_priority: float = 1.0
## The collision margin for the SolidClass' collision shapes. Not used in Godot Physics. See Shape3D docs for details.
@export var collision_shape_margin: float = 0.04

@export_group(\"Scripting\")
## The script file to associate with this SolidClass
## On building the map, this will be attached to any brush entities created via this classname
@export var script_class: Script

func _init():
	prefix = \"@SolidClass\"
"

[sub_resource type="Resource" id="Resource_m60k3"]
script = SubResource("GDScript_3gh3d")
spawn_type = 0
build_visuals = true
use_in_baked_light = true
shadow_casting_setting = 1
build_occlusion = true
render_layers = 1
collision_shape_type = 1
collision_layer = 1
collision_mask = 1
collision_priority = 1.0
collision_shape_margin = 0.04
classname = "worldspawn"
description = "World Entity"
qodot_internal = false
base_classes = Array[Resource]([])
class_properties = {}
class_property_descriptions = {}
meta_properties = {}
node_class = "StaticBody3D"
transient_node = false

[sub_resource type="Resource" id="Resource_rcbo5"]
script = SubResource("GDScript_3gh3d")
spawn_type = 3
build_visuals = true
use_in_baked_light = true
shadow_casting_setting = 1
build_occlusion = false
render_layers = 1
collision_shape_type = 1
collision_layer = 1
collision_mask = 1
collision_priority = 1.0
collision_shape_margin = 0.04
classname = "func_group"
description = "TrenchBroom Group"
qodot_internal = true
base_classes = Array[Resource]([])
class_properties = {}
class_property_descriptions = {}
meta_properties = {}
node_class = "StaticBody3D"
transient_node = false

[sub_resource type="Resource" id="Resource_ejsm8"]
script = SubResource("GDScript_3gh3d")
spawn_type = 1
build_visuals = true
use_in_baked_light = true
shadow_casting_setting = 1
build_occlusion = false
render_layers = 1
collision_shape_type = 1
collision_layer = 1
collision_mask = 1
collision_priority = 1.0
collision_shape_margin = 0.04
classname = "group"
description = "Brush Group"
qodot_internal = false
base_classes = Array[Resource]([])
class_properties = {}
class_property_descriptions = {}
meta_properties = {}
node_class = "StaticBody3D"
transient_node = false

[sub_resource type="Resource" id="Resource_7wp2m"]
script = SubResource("GDScript_3gh3d")
spawn_type = 1
build_visuals = true
use_in_baked_light = true
shadow_casting_setting = 1
build_occlusion = false
render_layers = 1
collision_shape_type = 0
collision_layer = 1
collision_mask = 1
collision_priority = 1.0
collision_shape_margin = 0.04
classname = "illusionary"
description = "Non-colliding Brush"
qodot_internal = false
base_classes = Array[Resource]([])
class_properties = {}
class_property_descriptions = {}
meta_properties = {}
node_class = "Node3D"
transient_node = false

[sub_resource type="GDScript" id="GDScript_o1dgt"]
script/source = "@tool
class_name PhysicsEntity
extends RigidBody3D

@export var properties: Dictionary :
	get:
		return properties
	set(new_properties):
		if(properties != new_properties):
			properties = new_properties
			update_properties()

func update_properties():
	if 'velocity' in properties:
		linear_velocity = properties['velocity']

	if 'mass' in properties:
		mass = properties.mass


func use():
	bounce()

func bounce():
	linear_velocity.y = 10
"

[sub_resource type="Resource" id="Resource_wk6xi"]
script = SubResource("GDScript_3gh3d")
spawn_type = 2
build_visuals = true
use_in_baked_light = true
shadow_casting_setting = 1
build_occlusion = false
render_layers = 1
collision_shape_type = 1
collision_layer = 1
collision_mask = 1
collision_priority = 1.0
collision_shape_margin = 0.04
script_class = SubResource("GDScript_o1dgt")
classname = "physics"
description = "Physics Brush"
qodot_internal = false
base_classes = Array[Resource]([])
class_properties = {
"mass": 1.0,
"velocity": Vector3(0, 0, 0)
}
class_property_descriptions = {}
meta_properties = {}
node_class = "RigidBody"
transient_node = false

[sub_resource type="GDScript" id="GDScript_tmpyr"]
script/source = "@tool
class_name QodotFGDBaseClass
extends QodotFGDClass

func _init():
	prefix = \"@BaseClass\"
"

[sub_resource type="Resource" id="Resource_chatw"]
script = SubResource("GDScript_tmpyr")
classname = "Targetname"
description = "Subscribes to actions (signal callbacks, reciever methods) performed by other entities with a matching 'target'."
qodot_internal = false
base_classes = Array[Resource]([])
class_properties = {
"targetname": ""
}
class_property_descriptions = {
"targetname": "Name of target to subscribe to."
}
meta_properties = {}
node_class = ""
transient_node = false

[sub_resource type="Resource" id="Resource_cwwmk"]
script = SubResource("GDScript_tmpyr")
classname = "Target"
description = "Performs actions (signal callbacks, methods) on entities with a matching 'targetname'."
qodot_internal = false
base_classes = Array[Resource]([])
class_properties = {
"target": ""
}
class_property_descriptions = {
"target": "Name of entity (targetname) to target."
}
meta_properties = {}
node_class = ""
transient_node = false

[sub_resource type="GDScript" id="GDScript_5feo7"]
script/source = "@tool
class_name QodotFGDPointClass
extends QodotFGDClass

func _init():
	prefix = \"@PointClass\"

# The scene file to associate with this PointClass
# On building the map, this scene will be instanced into the scene tree
@export_group (\"Scene\")
@export var scene_file: PackedScene

# The script file to associate with this PointClass
# On building the map, this will be attached to any brush entities created
# via this classname if no scene_file is specified
@export_group (\"Scripting\")
@export var script_class: Script

@export_group(\"Build\")
## Entity will use `angles`, `mangle`, or `angle` to determine rotations on QodotMap build, prioritizing the key value pairs in that order.
@export var apply_rotation_on_map_build := true
"

[sub_resource type="Resource" id="Resource_seuev"]
script = SubResource("GDScript_5feo7")
apply_rotation_on_map_build = true
classname = "signal"
description = "Name of signal to call target."
qodot_internal = false
base_classes = Array[Resource]([SubResource("Resource_chatw"), SubResource("Resource_cwwmk")])
class_properties = {
"signal_name": ""
}
class_property_descriptions = {
"signal_name": "Name of signal to call on target."
}
meta_properties = {
"size": AABB(-8, -8, -8, 8, 8, 8)
}
node_class = ""
transient_node = true

[sub_resource type="Resource" id="Resource_1ua38"]
script = SubResource("GDScript_5feo7")
apply_rotation_on_map_build = true
classname = "receiver"
description = "Calls methods on target."
qodot_internal = false
base_classes = Array[Resource]([SubResource("Resource_chatw"), SubResource("Resource_cwwmk")])
class_properties = {
"receiver_name": ""
}
class_property_descriptions = {
"reciever_name": "Name of method to call on target. "
}
meta_properties = {
"size": AABB(-8, -8, -8, 8, 8, 8)
}
node_class = ""
transient_node = true

[sub_resource type="Resource" id="Resource_qr74d"]
script = SubResource("GDScript_tmpyr")
classname = "Light"
description = ""
qodot_internal = false
base_classes = Array[Resource]([])
class_properties = {
"_color": Color(1, 1, 1, 1),
"delay": {
"Inverse distance falloff": 1,
"Inverse distance squared": 2,
"Inverse distance squared B": 5,
"Linear falloff (Default)": 0,
"Local minlight": 4,
"No falloff": 3
},
"light": 300,
"mangle": Vector3(0.005, 0, 0),
"wait": 1
}
class_property_descriptions = {
"_color": "Light color",
"delay": "Attenuation",
"light": "Brightness",
"mangle": "Spotlight angle",
"wait": "Fade distance multiplier"
}
meta_properties = {
"color": Color(1, 1, 0.156863, 1)
}
node_class = ""
transient_node = false

[sub_resource type="GDScript" id="GDScript_pwixr"]
script/source = "@tool
class_name QodotLight
extends QodotEntity

var light_node: Light3D = null

func update_properties():
	if not Engine.is_editor_hint():
		return
	
	for child in get_children():
		remove_child(child)
		child.queue_free()
	
	if 'mangle' in properties:
		light_node = SpotLight3D.new()
	
		var yaw = properties['mangle'].x
		var pitch = properties['mangle'].y
		light_node.rotate(Vector3.UP, deg_to_rad(180 + yaw))
		light_node.rotate(light_node.transform.basis.x, deg_to_rad(180 + pitch))
	
		if 'angle' in properties:
			light_node.set_param(Light3D.PARAM_SPOT_ANGLE, properties['angle'])
	else:
		light_node = OmniLight3D.new()
	
	var light_brightness = 300
	if 'light' in properties:
		light_brightness = properties['light']
		light_node.set_param(Light3D.PARAM_ENERGY, light_brightness / 100.0)
		light_node.set_param(Light3D.PARAM_INDIRECT_ENERGY, light_brightness / 100.0)
	
	var light_range := 1.0
	if 'wait' in properties:
		light_range = properties['wait']
	
	var normalized_brightness = light_brightness / 300.0
	light_node.set_param(Light3D.PARAM_RANGE, 16.0 * light_range * (normalized_brightness * normalized_brightness))
	
	var light_attenuation = 0
	if 'delay' in properties:
		light_attenuation = properties['delay']
	
	var attenuation = 0
	match light_attenuation:
		0:
			attenuation = 1.0
		1:
			attenuation = 0.5
		2:
			attenuation = 0.25
		3:
			attenuation = 0.15
		4:
			attenuation = 0
		5:
			attenuation = 0.9
		_:
			attenuation = 1
	
	light_node.set_param(Light3D.PARAM_ATTENUATION, attenuation)
	light_node.set_shadow(true)
	light_node.set_bake_mode(Light3D.BAKE_STATIC)
	
	var light_color = Color.WHITE
	if '_color' in properties:
		light_color = properties['_color']
	
	light_node.set_color(light_color)
	
	add_child(light_node)
	
	if is_inside_tree():
		var tree = get_tree()
		if tree:
			var edited_scene_root = tree.get_edited_scene_root()
			if edited_scene_root:
				light_node.set_owner(edited_scene_root)
"

[sub_resource type="Resource" id="Resource_wgprn"]
script = SubResource("GDScript_5feo7")
script_class = SubResource("GDScript_pwixr")
apply_rotation_on_map_build = true
classname = "light"
description = "Invisible light source"
qodot_internal = false
base_classes = Array[Resource]([SubResource("Resource_qr74d")])
class_properties = {
"angle": 0.0
}
class_property_descriptions = {
"angle": "Rotation Angle"
}
meta_properties = {
"size": AABB(-8, -8, -8, 8, 8, 8)
}
node_class = "Node3D"
transient_node = false

[sub_resource type="GDScript" id="GDScript_7edpf"]
script/source = "extends Area3D

signal trigger()
signal pressed()
signal released()

@export var properties: Dictionary :
	get:
		return properties # TODOConverter40 Non existent get function 
	set(new_properties):
		if(properties != new_properties):
			properties = new_properties
			update_properties()

var is_pressed = false
var base_translation = Vector3.ZERO
var axis := Vector3.DOWN
var speed := 8.0
var depth := 0.8
var release_delay := 0.0
var trigger_signal_delay :=  0.0
var press_signal_delay :=  0.0
var release_signal_delay :=  0.0

var overlaps := 0

func update_properties() -> void:
	if 'axis' in properties:
		axis = properties.axis.normalized()

	if 'speed' in properties:
		speed = properties.speed

	if 'depth' in properties:
		depth = float(properties.depth)

	if 'release_delay' in properties:
		release_delay = properties.release_delay

	if 'trigger_signal_delay' in properties:
		trigger_signal_delay = properties.trigger_signal_delay

	if 'press_signal_delay' in properties:
		press_signal_delay = properties.press_signal_delay

	if 'release_signal_delay' in properties:
		release_signal_delay = properties.release_signal_delay

func _init() -> void:
	connect(\"body_shape_entered\", body_shape_entered)
	connect(\"body_shape_exited\", body_shape_exited)

func _enter_tree() -> void:
	base_translation = position

func _process(delta: float) -> void:
	var target_position = base_translation + (axis * (depth if is_pressed else 0.0))
	position = position.lerp(target_position, speed * delta)

func body_shape_entered(body_id, body: Node, body_shape_idx: int, self_shape_idx: int) -> void:
	if body is StaticBody3D:
		return

	if overlaps == 0:
		press()

	overlaps += 1

func body_shape_exited(body_id, body: Node, body_shape_idx: int, self_shape_idx: int) -> void:
	if body is StaticBody3D:
		return

	overlaps -= 1
	if overlaps == 0:
		if release_delay == 0:
			release()
		elif release_delay > 0:
			await get_tree().create_timer(release_delay).timeout
			release()

func press() -> void:
	if is_pressed:
		return

	is_pressed = true

	emit_trigger()
	emit_pressed()

func emit_trigger() -> void:
	await get_tree().create_timer(trigger_signal_delay).timeout
	trigger.emit()

func emit_pressed() -> void:
	await get_tree().create_timer(press_signal_delay).timeout
	pressed.emit()

func release() -> void:
	if not is_pressed:
		return

	is_pressed = false

	await get_tree().create_timer(release_delay).timeout
	released.emit()
"

[sub_resource type="Resource" id="Resource_ub3ck"]
script = SubResource("GDScript_3gh3d")
spawn_type = 2
build_visuals = true
use_in_baked_light = true
shadow_casting_setting = 1
build_occlusion = false
render_layers = 1
collision_shape_type = 1
collision_layer = 1
collision_mask = 1
collision_priority = 1.0
collision_shape_margin = 0.04
script_class = SubResource("GDScript_7edpf")
classname = "button"
description = "Interactive button brush."
qodot_internal = false
base_classes = Array[Resource]([])
class_properties = {
"axis": Vector3(0, -1, 0),
"depth": 0.8,
"press_signal_delay": 0.0,
"release_delay": 0.0,
"release_signal_delay": 0.0,
"speed": 8.0,
"target": "",
"trigger_signal_delay": 0.0
}
class_property_descriptions = {
"axis": "Direction of movement when pressed.",
"depth": "How far to move along the axis when pressed.",
"press_signal_delay": "Seconds after press() is called, before emitting is own pressed signal.",
"release_delay": "Seconds after a physics body exits, before calling release()",
"release_signal_delay": "Seconds after release() is called, before emitting is own released signal.",
"speed": "Delta multiplier for a lerp weight to move the button to its desired position.",
"trigger_signal_delay": "Seconds after press() is called, before emitting the trigger signal."
}
meta_properties = {}
node_class = "Area3D"
transient_node = false

[sub_resource type="Resource" id="Resource_c2u2s"]
script = SubResource("GDScript_3gh3d")
spawn_type = 1
build_visuals = true
use_in_baked_light = true
shadow_casting_setting = 1
build_occlusion = false
render_layers = 1
collision_shape_type = 1
collision_layer = 1
collision_mask = 1
collision_priority = 1.0
collision_shape_margin = 0.04
classname = "detail"
description = "Detail Brush"
qodot_internal = false
base_classes = Array[Resource]([])
class_properties = {}
class_property_descriptions = {}
meta_properties = {}
node_class = "StaticBody3D"
transient_node = false

[sub_resource type="GDScript" id="GDScript_4n17b"]
script/source = "extends CharacterBody3D

@export var properties: Dictionary :
	get:
		return properties # TODOConverter40 Non existent get function 
	set(new_properties):
		if(properties != new_properties):
			properties = new_properties
			update_properties()

var base_transform: Transform3D
var offset_transform: Transform3D
var target_transform: Transform3D

var speed := 1.0

func update_properties() -> void:
	if 'translation' in properties:
		offset_transform.origin = properties.translation

	if 'rotation' in properties:
		offset_transform.basis = offset_transform.basis.rotated(Vector3.RIGHT, properties.rotation.x)
		offset_transform.basis = offset_transform.basis.rotated(Vector3.UP, properties.rotation.y)
		offset_transform.basis = offset_transform.basis.rotated(Vector3.FORWARD, properties.rotation.z)

	if 'scale' in properties:
		offset_transform.basis = offset_transform.basis.scaled(properties.scale)

	if 'speed' in properties:
		speed = properties.speed

func _process(delta: float) -> void:
	transform = transform.interpolate_with(target_transform, speed * delta)

func _ready() -> void:
	base_transform = transform
	target_transform = base_transform

func use() -> void:
	play_motion()

func play_motion() -> void:
	target_transform = base_transform * offset_transform

func reverse_motion() -> void:
	target_transform = base_transform
"

[sub_resource type="Resource" id="Resource_e737w"]
script = SubResource("GDScript_3gh3d")
spawn_type = 2
build_visuals = true
use_in_baked_light = true
shadow_casting_setting = 1
build_occlusion = false
render_layers = 1
collision_shape_type = 1
collision_layer = 1
collision_mask = 1
collision_priority = 1.0
collision_shape_margin = 0.04
script_class = SubResource("GDScript_4n17b")
classname = "mover"
description = "Moving brush."
qodot_internal = false
base_classes = Array[Resource]([])
class_properties = {
"rotation": Vector3(0, 0, 0),
"scale": Vector3(1, 1, 1),
"speed": 1.0,
"targetname": "",
"translation": Vector3(0, 0, 0)
}
class_property_descriptions = {}
meta_properties = {}
node_class = "CharacterBody3D"
transient_node = false

[sub_resource type="GDScript" id="GDScript_sjpam"]
script/source = "class_name QodotRotateEntity
extends CharacterBody3D

@export var properties: Dictionary :
	get:
		return properties # TODOConverter40 Non existent get function 
	set(new_properties):
		if(properties != new_properties):
			properties = new_properties
			update_properties()
	
var rotate_axis := Vector3.UP
var rotate_speed := 360.0

func update_properties():
	if 'axis' in properties:
		rotate_axis = properties['axis']

	if 'speed' in properties:
		rotate_speed = properties['speed']

func _ready() -> void:
	update_properties()

func _process(delta: float) -> void:
	rotate(rotate_axis, deg_to_rad(rotate_speed * delta))
"

[sub_resource type="Resource" id="Resource_drcx3"]
script = SubResource("GDScript_3gh3d")
spawn_type = 2
build_visuals = true
use_in_baked_light = true
shadow_casting_setting = 1
build_occlusion = false
render_layers = 1
collision_shape_type = 1
collision_layer = 1
collision_mask = 1
collision_priority = 1.0
collision_shape_margin = 0.04
script_class = SubResource("GDScript_sjpam")
classname = "rotate"
description = "Rotating Brush"
qodot_internal = false
base_classes = Array[Resource]([])
class_properties = {
"axis": Vector3(0, 1, 0),
"speed": 360.0
}
class_property_descriptions = {
"axis": "Rotation Axis",
"speed": "Rotation Speed"
}
meta_properties = {}
node_class = "CharacterBody3D"
transient_node = false

[sub_resource type="GDScript" id="GDScript_dvsnm"]
script/source = "extends Area3D

signal trigger()

func _ready():
	connect(\"body_entered\", handle_body_entered)

func handle_body_entered(body: Node):
	if body is StaticBody3D:
		return

	emit_signal(\"trigger\")
"

[sub_resource type="Resource" id="Resource_4e360"]
script = SubResource("GDScript_3gh3d")
spawn_type = 2
build_visuals = false
use_in_baked_light = true
shadow_casting_setting = 1
build_occlusion = false
render_layers = 1
collision_shape_type = 1
collision_layer = 1
collision_mask = 1
collision_priority = 1.0
collision_shape_margin = 0.04
script_class = SubResource("GDScript_dvsnm")
classname = "trigger"
description = "Trigger Volume"
qodot_internal = false
base_classes = Array[Resource]([])
class_properties = {
"target": ""
}
class_property_descriptions = {}
meta_properties = {}
node_class = "Area3D"
transient_node = false

[sub_resource type="Resource" id="Resource_fetpv"]
script = SubResource("GDScript_3gh3d")
spawn_type = 2
build_visuals = true
use_in_baked_light = true
shadow_casting_setting = 1
build_occlusion = false
render_layers = 1
collision_shape_type = 1
collision_layer = 1
collision_mask = 1
collision_priority = 1.0
collision_shape_margin = 0.04
classname = "wall"
description = "Basic entity brush."
qodot_internal = false
base_classes = Array[Resource]([])
class_properties = {}
class_property_descriptions = {}
meta_properties = {}
node_class = "StaticBody3D"
transient_node = false

[sub_resource type="GDScript" id="GDScript_2r6wl"]
script/source = "@tool
class_name QodotFGDFile
extends Resource

## A node used to to express a set of entity definitions that can be exproted

#psuedo-button to export
@export var export_file: bool:
	get:
		return export_file # TODO Converter40 Non existent get function
	set(new_export_file):
		if new_export_file != export_file:
			do_export_file()
func do_export_file():
	if Engine.is_editor_hint() and get_fgd_classes().size() > 0:
				if target_folder.is_empty():
					print(\"Skipping export: No target folder\")
					return

				if fgd_name == \"\":
					print(\"Skipping export: Empty FGD name\")

				var fgd_file = target_folder + \"/\" + fgd_name + \".fgd\"

				print(\"Exporting FGD to \", fgd_file)
				var file_obj := FileAccess.open(fgd_file, FileAccess.WRITE)
				file_obj.store_string(build_class_text())
				file_obj.close()
@export_global_dir var target_folder : String # (String, DIR, GLOBAL)
@export var fgd_name: String = \"Qodot\"
@export var base_fgd_files: Array[Resource] = [] # (Array, Resource)
@export var entity_definitions: Array[Resource] = [ # (Array, Resource)
]

func build_class_text() -> String:
	var res : String = \"\"

	for base_fgd in base_fgd_files:
		res += base_fgd.build_class_text()

	var entities = get_fgd_classes()
	for ent in entities:
		if ent.qodot_internal:
			continue
		
		var ent_text = ent.build_def_text()
		res += ent_text
		if ent != entities[-1]:
			res += \"\\n\"
	return res

#This getter does a little bit of validation. Providing only an array of non-null uniquely-named entity definitions
func get_fgd_classes() -> Array:
	var res : Array = []
	for cur_ent_def_ind in range(entity_definitions.size()):
		var cur_ent_def = entity_definitions[cur_ent_def_ind]
		if cur_ent_def == null:
			continue
		elif not (cur_ent_def is QodotFGDClass):
			printerr(\"Bad value in entity definition set at position %s! Not an entity defintion.\" % cur_ent_def_ind)
			continue
		res.append(cur_ent_def)
	return res

func get_entity_definitions() -> Dictionary:
	var res : Dictionary = {}

	for base_fgd in base_fgd_files:
		var fgd_res = base_fgd.get_entity_definitions()
		for key in fgd_res:
			res[key] = fgd_res[key]

	for ent in get_fgd_classes():
		if ent is QodotFGDPointClass or ent is QodotFGDSolidClass:
			var entity_def = ent.duplicate()
			var meta_properties := {}
			var class_properties := {}
			var class_property_descriptions := {}

			for base_class in _generate_base_class_list(entity_def):
				for meta_property in base_class.meta_properties:
					meta_properties[meta_property] = base_class.meta_properties[meta_property]

				for class_property in base_class.class_properties:
					class_properties[class_property] = base_class.class_properties[class_property]

				for class_property_desc in base_class.class_property_descriptions:
					class_property_descriptions[class_property_desc] = base_class.class_property_descriptions[class_property_desc]

			for meta_property in entity_def.meta_properties:
				meta_properties[meta_property] = entity_def.meta_properties[meta_property]

			for class_property in entity_def.class_properties:
				class_properties[class_property] = entity_def.class_properties[class_property]

			for class_property_desc in entity_def.class_property_descriptions:
				class_property_descriptions[class_property_desc] = entity_def.class_property_descriptions[class_property_desc]

			entity_def.meta_properties = meta_properties
			entity_def.class_properties = class_properties
			entity_def.class_property_descriptions = class_property_descriptions

			res[ent.classname] = entity_def
	return res

func _generate_base_class_list(entity_def : Resource, visited_base_classes = []) -> Array:
	var base_classes : Array = []

	visited_base_classes.append(entity_def.classname)

	# End recursive search if no more base_classes
	if len(entity_def.base_classes) == 0:
		return base_classes

	# Traverse up to the next level of hierarchy, if not already visited
	for base_class in entity_def.base_classes:
		if not base_class.classname in visited_base_classes:
			base_classes.append(base_class)
			base_classes += _generate_base_class_list(base_class, visited_base_classes)
		else:
			printerr(str(\"Entity '\", entity_def.classname,\"' contains cycle/duplicate to Entity '\", base_class.classname, \"'\"))

	return base_classes
"

[sub_resource type="Resource" id="Resource_b0jr1"]
script = SubResource("GDScript_2r6wl")
export_file = false
target_folder = ""
fgd_name = "Qodot"
base_fgd_files = Array[Resource]([])
entity_definitions = Array[Resource]([SubResource("Resource_m60k3"), SubResource("Resource_rcbo5"), SubResource("Resource_ejsm8"), SubResource("Resource_7wp2m"), SubResource("Resource_wk6xi"), SubResource("Resource_seuev"), SubResource("Resource_1ua38"), SubResource("Resource_wgprn"), SubResource("Resource_ub3ck"), SubResource("Resource_c2u2s"), SubResource("Resource_e737w"), SubResource("Resource_drcx3"), SubResource("Resource_4e360"), SubResource("Resource_fetpv")])

[sub_resource type="StandardMaterial3D" id="StandardMaterial3D_ogw02"]

[sub_resource type="StandardMaterial3D" id="StandardMaterial3D_o14uo"]

[sub_resource type="StandardMaterial3D" id="StandardMaterial3D_kfflp"]

[sub_resource type="ArrayMesh" id="ArrayMesh_jlbky"]
_surfaces = [{
"aabb": AABB(-6, -1, -7, 22, 2.00001, 46),
"attribute_data": PackedByteArray(0, 0, 64, 63, 0, 0, 0, 190, 0, 0, 64, 63, 0, 0, 0, 62, 0, 0, 0, 192, 0, 0, 0, 62, 0, 0, 0, 192, 0, 0, 0, 190, 0, 0, 96, 191, 0, 0, 0, 190, 0, 0, 156, 64, 0, 0, 0, 190, 0, 0, 156, 64, 0, 0, 0, 62, 0, 0, 96, 191, 0, 0, 0, 62, 0, 0, 96, 63, 0, 0, 0, 192, 0, 0, 96, 63, 0, 0, 64, 63, 0, 0, 156, 192, 0, 0, 64, 63, 0, 0, 156, 192, 0, 0, 0, 192, 0, 0, 96, 191, 0, 0, 0, 192, 0, 0, 156, 64, 0, 0, 0, 192, 0, 0, 156, 64, 0, 0, 64, 63, 0, 0, 96, 191, 0, 0, 64, 63, 0, 0, 96, 63, 0, 0, 0, 190, 0, 0, 96, 63, 0, 0, 0, 62, 0, 0, 156, 192, 0, 0, 0, 62, 0, 0, 156, 192, 0, 0, 0, 190, 0, 0, 64, 191, 0, 0, 0, 190, 0, 0, 0, 64, 0, 0, 0, 190, 0, 0, 0, 64, 0, 0, 0, 62, 0, 0, 64, 191, 0, 0, 0, 62),
"format": 34359742487,
"index_count": 36,
"index_data": PackedByteArray(0, 0, 1, 0, 2, 0, 0, 0, 2, 0, 3, 0, 4, 0, 5, 0, 6, 0, 4, 0, 6, 0, 7, 0, 8, 0, 9, 0, 10, 0, 8, 0, 10, 0, 11, 0, 12, 0, 13, 0, 14, 0, 12, 0, 14, 0, 15, 0, 16, 0, 17, 0, 18, 0, 16, 0, 18, 0, 19, 0, 20, 0, 21, 0, 22, 0, 20, 0, 22, 0, 23, 0),
"material": SubResource("StandardMaterial3D_o14uo"),
"name": "Ground/Ground_20-128x128",
"primitive": 3,
"uv_scale": Vector4(0, 0, 0, 0),
"vertex_count": 24,
"vertex_data": PackedByteArray(0, 0, 192, 192, 0, 0, 128, 63, 0, 0, 224, 192, 0, 0, 192, 192, 0, 0, 128, 191, 0, 0, 224, 192, 0, 0, 128, 65, 0, 0, 128, 191, 0, 0, 224, 192, 0, 0, 128, 65, 0, 0, 128, 63, 0, 0, 224, 192, 0, 0, 192, 192, 0, 0, 128, 63, 0, 0, 224, 192, 0, 0, 192, 192, 0, 0, 128, 63, 0, 0, 28, 66, 0, 0, 192, 192, 0, 0, 128, 191, 0, 0, 28, 66, 0, 0, 192, 192, 0, 0, 128, 191, 0, 0, 224, 192, 0, 0, 128, 65, 0, 0, 128, 191, 0, 0, 224, 192, 0, 0, 192, 192, 0, 0, 128, 191, 0, 0, 224, 192, 0, 0, 192, 192, 0, 0, 128, 191, 0, 0, 28, 66, 0, 0, 128, 65, 0, 0, 128, 191, 0, 0, 28, 66, 0, 0, 128, 65, 0, 0, 128, 63, 0, 0, 224, 192, 0, 0, 128, 65, 0, 0, 128, 63, 0, 0, 28, 66, 0, 0, 192, 192, 0, 0, 128, 63, 0, 0, 28, 66, 0, 0, 192, 192, 0, 0, 128, 63, 0, 0, 224, 192, 0, 0, 128, 65, 0, 0, 128, 63, 0, 0, 224, 192, 0, 0, 128, 65, 0, 0, 128, 191, 0, 0, 224, 192, 0, 0, 128, 65, 0, 0, 128, 191, 0, 0, 28, 66, 0, 0, 128, 65, 0, 0, 128, 63, 0, 0, 28, 66, 0, 0, 192, 192, 0, 0, 128, 63, 0, 0, 28, 66, 0, 0, 128, 65, 0, 0, 128, 63, 0, 0, 28, 66, 0, 0, 128, 65, 0, 0, 128, 191, 0, 0, 28, 66, 0, 0, 192, 192, 0, 0, 128, 191, 0, 0, 28, 66, 255, 255, 255, 255, 0, 0, 255, 191, 255, 255, 255, 255, 0, 0, 255, 191, 255, 255, 255, 255, 0, 0, 255, 191, 255, 255, 255, 255, 0, 0, 255, 191, 0, 0, 255, 127, 255, 127, 255, 191, 0, 0, 255, 127, 255, 127, 255, 191, 0, 0, 255, 127, 255, 127, 255, 191, 0, 0, 255, 127, 255, 127, 255, 191, 255, 127, 0, 0, 255, 255, 255, 255, 255, 127, 0, 0, 255, 255, 255, 255, 255, 127, 0, 0, 255, 255, 255, 255, 255, 127, 0, 0, 255, 255, 255, 255, 255, 127, 255, 255, 255, 127, 255, 191, 255, 127, 255, 255, 255, 127, 255, 191, 255, 127, 255, 255, 255, 127, 255, 191, 255, 127, 255, 255, 255, 127, 255, 191, 255, 255, 255, 127, 255, 255, 255, 255, 255, 255, 255, 127, 255, 255, 255, 255, 255, 255, 255, 127, 255, 255, 255, 255, 255, 255, 255, 127, 255, 255, 255, 255, 255, 127, 255, 127, 255, 255, 255, 191, 255, 127, 255, 127, 255, 255, 255, 191, 255, 127, 255, 127, 255, 255, 255, 191, 255, 127, 255, 127, 255, 255, 255, 191)
}, {
"aabb": AABB(7, 1, 8, 7, 6.00001, 26),
"attribute_data": PackedByteArray(0, 0, 192, 190, 0, 0, 96, 191, 0, 0, 192, 190, 0, 0, 0, 190, 0, 0, 160, 191, 0, 0, 0, 190, 0, 0, 160, 191, 0, 0, 96, 191, 0, 0, 128, 63, 0, 0, 96, 191, 0, 0, 136, 64, 0, 0, 96, 191, 0, 0, 136, 64, 0, 0, 0, 190, 0, 0, 128, 63, 0, 0, 0, 190, 0, 0, 128, 191, 0, 0, 160, 191, 0, 0, 128, 191, 0, 0, 192, 190, 0, 0, 136, 192, 0, 0, 192, 190, 0, 0, 136, 192, 0, 0, 160, 191, 0, 0, 128, 63, 0, 0, 160, 191, 0, 0, 136, 64, 0, 0, 160, 191, 0, 0, 136, 64, 0, 0, 192, 190, 0, 0, 128, 63, 0, 0, 192, 190, 0, 0, 128, 191, 0, 0, 96, 191, 0, 0, 128, 191, 0, 0, 0, 190, 0, 0, 136, 192, 0, 0, 0, 190, 0, 0, 136, 192, 0, 0, 96, 191, 0, 0, 192, 62, 0, 0, 96, 191, 0, 0, 160, 63, 0, 0, 96, 191, 0, 0, 160, 63, 0, 0, 0, 190, 0, 0, 192, 62, 0, 0, 0, 190),
"format": 34359742487,
"index_count": 36,
"index_data": PackedByteArray(0, 0, 1, 0, 2, 0, 0, 0, 2, 0, 3, 0, 4, 0, 5, 0, 6, 0, 4, 0, 6, 0, 7, 0, 8, 0, 9, 0, 10, 0, 8, 0, 10, 0, 11, 0, 12, 0, 13, 0, 14, 0, 12, 0, 14, 0, 15, 0, 16, 0, 17, 0, 18, 0, 16, 0, 18, 0, 19, 0, 20, 0, 21, 0, 22, 0, 20, 0, 22, 0, 23, 0),
"material": SubResource("StandardMaterial3D_kfflp"),
"name": "Rust/Rust_05-128x128",
"primitive": 3,
"uv_scale": Vector4(0, 0, 0, 0),
"vertex_count": 24,
"vertex_data": PackedByteArray(0, 0, 224, 64, 0, 0, 224, 64, 0, 0, 0, 65, 0, 0, 224, 64, 0, 0, 128, 63, 0, 0, 0, 65, 0, 0, 96, 65, 0, 0, 128, 63, 0, 0, 0, 65, 0, 0, 96, 65, 0, 0, 224, 64, 0, 0, 0, 65, 0, 0, 224, 64, 0, 0, 224, 64, 0, 0, 0, 65, 0, 0, 224, 64, 0, 0, 224, 64, 0, 0, 8, 66, 0, 0, 224, 64, 0, 0, 128, 63, 0, 0, 8, 66, 0, 0, 224, 64, 0, 0, 128, 63, 0, 0, 0, 65, 0, 0, 96, 65, 0, 0, 128, 63, 0, 0, 0, 65, 0, 0, 224, 64, 0, 0, 128, 63, 0, 0, 0, 65, 0, 0, 224, 64, 0, 0, 128, 63, 0, 0, 8, 66, 0, 0, 96, 65, 0, 0, 128, 63, 0, 0, 8, 66, 0, 0, 96, 65, 0, 0, 224, 64, 0, 0, 0, 65, 0, 0, 96, 65, 0, 0, 224, 64, 0, 0, 8, 66, 0, 0, 224, 64, 0, 0, 224, 64, 0, 0, 8, 66, 0, 0, 224, 64, 0, 0, 224, 64, 0, 0, 0, 65, 0, 0, 96, 65, 0, 0, 224, 64, 0, 0, 0, 65, 0, 0, 96, 65, 0, 0, 128, 63, 0, 0, 0, 65, 0, 0, 96, 65, 0, 0, 128, 63, 0, 0, 8, 66, 0, 0, 96, 65, 0, 0, 224, 64, 0, 0, 8, 66, 0, 0, 224, 64, 0, 0, 224, 64, 0, 0, 8, 66, 0, 0, 96, 65, 0, 0, 224, 64, 0, 0, 8, 66, 0, 0, 96, 65, 0, 0, 128, 63, 0, 0, 8, 66, 0, 0, 224, 64, 0, 0, 128, 63, 0, 0, 8, 66, 255, 255, 255, 255, 0, 0, 255, 191, 255, 255, 255, 255, 0, 0, 255, 191, 255, 255, 255, 255, 0, 0, 255, 191, 255, 255, 255, 255, 0, 0, 255, 191, 0, 0, 255, 127, 255, 127, 255, 191, 0, 0, 255, 127, 255, 127, 255, 191, 0, 0, 255, 127, 255, 127, 255, 191, 0, 0, 255, 127, 255, 127, 255, 191, 255, 127, 0, 0, 255, 255, 255, 255, 255, 127, 0, 0, 255, 255, 255, 255, 255, 127, 0, 0, 255, 255, 255, 255, 255, 127, 0, 0, 255, 255, 255, 255, 255, 127, 255, 255, 255, 127, 255, 191, 255, 127, 255, 255, 255, 127, 255, 191, 255, 127, 255, 255, 255, 127, 255, 191, 255, 127, 255, 255, 255, 127, 255, 191, 255, 255, 255, 127, 255, 255, 255, 255, 255, 255, 255, 127, 255, 255, 255, 255, 255, 255, 255, 127, 255, 255, 255, 255, 255, 255, 255, 127, 255, 255, 255, 255, 255, 127, 255, 127, 255, 255, 255, 191, 255, 127, 255, 127, 255, 255, 255, 191, 255, 127, 255, 127, 255, 255, 255, 191, 255, 127, 255, 127, 255, 255, 255, 191)
}]

[sub_resource type="StandardMaterial3D" id="StandardMaterial3D_nl18r"]
albedo_texture = ExtResource("3_o4pdu")

[sub_resource type="StandardMaterial3D" id="StandardMaterial3D_rtnje"]
albedo_texture = ExtResource("4_ovrrc")

[sub_resource type="ArrayOccluder3D" id="ArrayOccluder3D_ry434"]
vertices = PackedVector3Array(-6, 1, -7, -6, -1, -7, 16, -1, -7, 16, 1, -7, -6, 1, -7, -6, 1, 39, -6, -1, 39, -6, -1, -7, 16, -1, -7, -6, -1, -7, -6, -1, 39, 16, -1, 39, 16, 1, -7, 16, 1, 39, -6, 1, 39, -6, 1, -7, 16, 1, -7, 16, -1, -7, 16, -1, 39, 16, 1, 39, -6, 1, 39, 16, 1, 39, 16, -1, 39, -6, -1, 39, 7, 7, 8, 7, 1, 8, 14, 1, 8, 14, 7, 8, 7, 7, 8, 7, 7, 34, 7, 1, 34, 7, 1, 8, 14, 1, 8, 7, 1, 8, 7, 1, 34, 14, 1, 34, 14, 7, 8, 14, 7, 34, 7, 7, 34, 7, 7, 8, 14, 7, 8, 14, 1, 8, 14, 1, 34, 14, 7, 34, 7, 7, 34, 14, 7, 34, 14, 1, 34, 7, 1, 34)
indices = PackedInt32Array(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 25, 26, 24, 26, 27, 28, 29, 30, 28, 30, 31, 32, 33, 34, 32, 34, 35, 36, 37, 38, 36, 38, 39, 40, 41, 42, 40, 42, 43, 44, 45, 46, 44, 46, 47)

[sub_resource type="ConvexPolygonShape3D" id="ConvexPolygonShape3D_fi3kp"]
points = PackedVector3Array(-6, 1, -7, -6, -1, -7, 16, -1, -7, 16, 1, -7, -6, 1, 39, -6, -1, 39, 16, -1, 39, 16, 1, 39)

[sub_resource type="ConvexPolygonShape3D" id="ConvexPolygonShape3D_fsnpm"]
points = PackedVector3Array(7, 7, 8, 7, 1, 8, 14, 1, 8, 14, 7, 8, 7, 7, 34, 7, 1, 34, 14, 1, 34, 14, 7, 34)

[sub_resource type="BoxShape3D" id="BoxShape3D_bmhf1"]
size = Vector3(1000, 5, 1000)

[node name="dog_hotel" type="Node3D"]
process_mode = 1

[node name="hide_0" type="Node3D" parent="."]
script = SubResource("GDScript_x1wqk")
map_file = "C:/Users/Archevia/Documents/GodotEngineProjects/lasercutter_acerola_jam/maps/hide_0.map"
entity_fgd = SubResource("Resource_b0jr1")
texture_file_extensions = PackedStringArray("png", "jpg", "jpeg", "bmp")
default_material = SubResource("StandardMaterial3D_ogw02")

[node name="entity_0_worldspawn" type="StaticBody3D" parent="hide_0"]

[node name="entity_0_mesh_instance" type="MeshInstance3D" parent="hide_0/entity_0_worldspawn"]
mesh = SubResource("ArrayMesh_jlbky")
surface_material_override/0 = SubResource("StandardMaterial3D_nl18r")
surface_material_override/1 = SubResource("StandardMaterial3D_rtnje")

[node name="entity_0_occluder_instance" type="OccluderInstance3D" parent="hide_0/entity_0_worldspawn"]
occluder = SubResource("ArrayOccluder3D_ry434")

[node name="entity_0_brush_0_collision_shape" type="CollisionShape3D" parent="hide_0/entity_0_worldspawn"]
shape = SubResource("ConvexPolygonShape3D_fi3kp")

[node name="entity_0_brush_1_collision_shape" type="CollisionShape3D" parent="hide_0/entity_0_worldspawn"]
shape = SubResource("ConvexPolygonShape3D_fsnpm")

[node name="DirectionalLight3D" type="DirectionalLight3D" parent="."]
transform = Transform3D(1, 0, 0, 0, -0.129782, 0.991543, 0, -0.991543, -0.129782, 0, -12.3455, 0)
light_color = Color(0.709804, 0.741176, 0.898039, 1)

[node name="Yua_Player" parent="." instance=ExtResource("5_8l85i")]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, -0.15181, 1.0056, 5.92802)

[node name="Floor-col2" parent="." instance=ExtResource("6_1ch45")]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, -7.70309, 0.999912, 0)

[node name="wall_up" parent="." instance=ExtResource("7_7kujf")]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1.02146, 0)

[node name="wall_up2" parent="." instance=ExtResource("7_7kujf")]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 1.98441, 1.02146, 0)

[node name="wall_up3" parent="." instance=ExtResource("7_7kujf")]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 3.98441, 1.02146, 0)

[node name="Trans_Level" type="Area3D" parent="."]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0, -11.8401, 0)

[node name="Death_Puppy" type="CollisionShape3D" parent="Trans_Level"]
shape = SubResource("BoxShape3D_bmhf1")
script = ExtResource("8_40vij")

[connection signal="body_shape_entered" from="Trans_Level" to="Trans_Level/Death_Puppy" method="_on_trans_level_body_shape_entered"]
